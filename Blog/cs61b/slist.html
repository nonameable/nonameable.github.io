<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>SList - DoubleChain</title>
    <!-- The style.css file allows you to change the look of your web pages.
         If you include the next line in all your web pages, they will all share the same look.
         This makes it easier to make new pages for your site. -->
    <!--// apparently this is not a closing tag. -->
  </head>
  <body>
  <header>
    <h1 align="center" >Welcome to nonameable.github.io </h1>
    <nav style = "text-align: center; vertical align: middle;"> <!-- I don't know if its good to give it style like this-->
    
    <a href="/index.html">Home</a> 
    <a href="acomplishments.html">List</a> 
    <a href="/schoolWork.html"> School Work</a> 
    <a href="/math.html">Math</a>
    <a href="/courses.html">Courses</a>
  
    </nav>

  </header>
    
    
    <section class="text">
      <h1>Node list, sentinel list</h1>

      <p>Node linked list are going to be an improvment from our schemelike linked list. This is because when we look at the implementation of IntList, sometimes is hard to follow all the references, and also there is no way for us to represent an empty list, and that is a pretty useful feature to have! (available in python or Matlab). What we're going to do is rebrand some things, even the name.</p>

      <p>We are going to create two new classes: <strong>IntNode </strong> which is going to be the one representing the node and also<strong>SList</strong>, representing the controller of the whole list. You can find my own version of Josh Hug implementation in my github repo here: <br>
      <a href="https://github.com/nonameable/CoolDataStructures/tree/master/SList">SList and IntNode implementetation (github)</a>

      </p>

      <div id = "explainshot">
        <table width=100% height=100%>
      <tr>
      <td style = "text-align: center; vertical align: middle;">
          <img src="/Blog/cs61b/images/intlistvsslist.png"  height  = "240"  width = "300">
      </td>
      </tr>
      </table>
      </div>

      <h2>LINKED LISTS (a recursive data type) </h2>
      <p>
      We discussed the idea of a Scheme-like list in Java which we called a linked list. A linked list is made up of nodes.  Each node has two components:  an value, and a reference to the tail node in the list.  These components are analogous to "car" and "cdr" in Scheme.  However, our node is an explicitly defined object. <br> <br>

        public class IntList {          // IntList is a recursive type <br>
          public int value; <br>
          public IntList tail;          // Here we're using IntList before <br>
        }                                //   we've finished declaring it.


      </p>

      <p>    
      Note that an SListNode is structually EXACTLY the same as an IntList. The only differences are the class name and the field name difference. However, we'll conceptualize how this class is used in a completely different way. <br>
      II. Second, we'll create a separate List class, whose job is to maintain the head (first node) of the list.  We will put many of the methods that operate on lists in the SList class, rather than the SlistNode class. These methods are: insertFront() - insertBack() - size().
      </p>

      <h2>IMPROVEMENTS</h2>

      <p>
      Now, if you look at the code, I have implemented insertBack and insertFront and they are pretty straight forward. What about size? If you try to implement this method, let's say, recursively, you will find yourself needing a helper method. I don't currently konw why do they use those, and the only anserr I might imagine is that they want the method size() to be as simple to use as possible, and having the other method allows them having ugly parameter calls, as the one necessary to get the size() function working. You can see the implementation of this helper method in my repo.
      </p>
      <p>
      This implementation,  however, is problematic as our SList gets larger and larger. We are engineers, we don't want to pass thorugh the whole list just the get its size. What if we have a variable that stores the current size of the SList? Yeah! We could change it's value everytime we add or remove something from the list. In the repo you will find both implementations in the same class. I might create a tester class to show you the runtime with larger SLists.
      </p>

      <p>
      Now, remember I told you it was impossible to have an empty list with the IntList implementation? Well, we can now. The only thing we need to do is add another constructor to the SList class that accepts no first node, and then set the front to null and its size to zero. Piece of cake! Wait, if I run the tests I get a null pinter exception. What happened? Wait! The insertBack() method gives us an special case when we have an empty list, as there is no p.next! Well, a conditional seems appropiate and it is. Nonvetheless, this solution is really ugly. 
      </p>

       <div id = "explainshot">
       <table width=100% height=100%>
       <tr>
       <td style = "text-align: center; vertical align: middle;">
          <img src="/Blog/cs61b/images/improvesSList.png"  height  = "240"  width = "300">
       </td>
       </tr>
      </table>
      </div>

      <p>How are we going to meake this better? Well, the answer is going to make us change a lot fo the code, so I have now created a new class and its correspondient tests and launcher in which our 'ugly' implementation is going to lay: SListNosentinel (does that give you any hints?) Let's leave SList and the rest for the on with the sentinel. SENTINEL!</p>

      <p>A sentinel node is an IntNode which front is always pointing to. This allows us to avoid the "bad spot" which makes us consider a bunch of special cases. The onyl thing we have to consider is that we have to make smarter code, both when we are implementing the SList class and also when we are working on it with other classes.</p>

       <div id = "explainshot">
       <table width=100% height=100%>
       <tr>
       <td style = "text-align: center; vertical align: middle;">
          <img src="/Blog/cs61b/images/sentinel.png"  height  = "240"  width = "300">
       </td>
       </tr>
      </table>
      </div> 

      <p>A sentinel node is really good, elegant and eficient because it makes use of a concept call <strong>Invariant</strong> :</p>

      <div id = "explainshot">
       <table width=100% height=100%>
       <tr>
       <td style = "text-align: center; vertical align: middle;">
          <img src="/Blog/cs61b/images/invariants.png"  height  = "240"  width = "300">
       </td>
       </tr>
      </table>
      </div> 

      <h2>Doubly Linked List / Double chain!</h2>
      <p>
        We have already implemented an SList with a sentinel node, which allowed us to have an invariant, write better and cleaner code and finally, have a sompler data structure with the same functionalities. Now, as we are grow as engineers, we must notice that what might make our programs slow down or have a downside in performance when doing sertain types of tasks. This is the case of the insertBack operation, which is easy at first when we have less than ten, but could you imagine doing that when having an Slist with size 1000 or bigger? let's say every operation is made in 0.001 seconds. In my University since it was founded, around 70000 Students have entered and graduated. Imagine the pain of the admissions officer when adding a new student: going through the whole list will take him or her more than one minute! <br>
        That is why we have to come up with another data structure, which performs better than but it's inspired by our SList: A doble linked list. This is just an SList with also references to the previous node. This, however, is not sufficient: we might be ablt to find previous things easier, but still adding node to the end of the list takes us a lot. Waht we have to thake advantage of our sentinel node, and make a circular Doubly LinkedList, or better a <strong>Double Chain!</strong>.

        <div id = "explainshot">
       <table width=100% height=100%>
       <tr>
       <td style = "text-align: center; vertical align: middle;">
          <img src="/Blog/cs61b/images/doublechain.png"  height  = "240"  width = "300">
       </td>
       </tr>
      </table>
      </div> 

      <p>
        A double chain is made just making the next item of the back of the list, the previous item of the sentinel. That's all! This allows us to go back even faster, and do not waste resources! <br>
        In the image above you'll see a diagram with this double chain, and my personal implementation, including tests, are in my <a href="https://github.com/nonameable/CoolDataStructures">CoolDataStructures repository</a>. 
      </p>
      

    </section>
   

    <footer>
    <nav style = "text-align: center; vertical align: middle;">
    
    <a href="/index.html">Home</a> 
    <a href="acomplishments.html">List</a> 
    <a href="/schoolWork.html"> School Work</a> 
    <a href="/math.html">Math</a>
    <a href="/courses.html">Courses</a>
    </nav>
      <p align="center" > Made by <b>nonameable</b> </p>
    </footer>

  </body>
</html>
