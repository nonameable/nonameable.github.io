<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>The web site of nonameable</title>
    <!-- The style.css file allows you to change the look of your web pages.
         If you include the next line in all your web pages, they will all share the same look.
         This makes it easier to make new pages for your site. -->
    <!--// apparently this is not a closing tag. -->
  </head>
  <body>
  <header>
    <h1 align="center" >Welcome to nonameable.github.io </h1>
    <nav style = "text-align: center; vertical align: middle;"> <!-- I don't know if its good to give it style like this-->
    
    <a href="/index.html">Home</a> 
    <a href="acomplishments.html">List</a> 
    <a href="/schoolWork.html"> School Work</a> 
    <a href="/math.html">Math</a>
    <a href="/courses.html">Courses</a>
  
    </nav>

  </header>
    
    
    <section class="text">
      <h1>Node list, sentinel list</h1>

      <p>Node linked list are going to be an improvment from our schemelike linked list. This is because when we look at the implementation of IntList, sometimes is hard to follow all the references, and also there is no way for us to represent an empty list, and that is a pretty useful feature to have! (available in python or Matlab). What we're going to do is rebrand some things, even the name.</p>

      <p>We are going to create two new classes: <strong>IntNode </strong> which is going to be the one representing the node and also<strong>SList</strong>, representing the controller of the whole list. You can find my own version of Josh Hug implementation in my github repo here: <br>
      <a href="https://github.com/nonameable/CoolDataStructures/tree/master/SList">SList and IntNode implementetation (github)</a>

      </p>

      <section id = "explainshot">
        <table width=100% height=100%>
      <tr>
      <td style = "text-align: center; vertical align: middle;">
          <img src="/Blog/cs61b/images/intlistvsslist.png"  height  = "240"  width = "300">
      </td>
      </tr>
      </table>
      </section>

      <h2>LINKED LISTS (a recursive data type) </h2>
      <p>
      We discussed the idea of a Scheme-like list in Java which we called a linked list. A linked list is made up of nodes.  Each node has two components:  an value, and a reference to the tail node in the list.  These components are analogous to "car" and "cdr" in Scheme.  However, our node is an explicitly defined object. <br> <br>

        public class IntList {          // IntList is a recursive type <br>
          public int value; <br>
          public IntList tail;          // Here we're using IntList before <br>
        }                                //   we've finished declaring it.


      </p>

      <p>    
        Note that an SListNode is structually EXACTLY the same as an IntList. The only differences are the class name and the field name difference. However, we'll conceptualize how this class is used in a completely different way. <br>
        II. Second, we'll create a separate List class, whose job is to maintain the head (first node) of the list.  We will put many of the methods that operate on lists in the SList class, rather than the SlistNode class. These methods are: insertFront() - insertBack() - size().
        </p>
        <p>
        Now, if you look at the code, I have implemented insertBack and insertFront and they are pretty straight forward. Waht about size? If you try to implement this method, let's say, recursively, you will find yourself needing a helper method. I don't currently konw why do they use those, and the only anserr I might imagine is that they want the method size() to be as simple to use as possible, and having the other method allows them having ugly parameter calls, as the one necessary to get the size() function working. You can see the implementation of this helper method in my repo.
        </p>
        <p>
        This implementation,  however, is problematic as our SList gets larger and larger. We are engineers, we don't want to pass thorugh the whole list just the get its size. What if we have a variable that stores the current size of the SList? Yeah! We could change it's value everytime we add or remove something from the list. In the repo you will find both implementations in the same class. I might create a tester class to show you the runtime with larger SLists.
        </p>

        <p>
        Now, remember I told you it was impossible to have an empty list with the IntList implementation? Well, we can now. The only thing we need to do is add another constructor to the SList class that accepts no first node, and then set the front to null and its size to zero. Piece of cake! Wait, if I run the tests I get a null pinter exception. What happened? Wait! The insertBack() method gives us an special case when we have an empty list, as there is no p.next! Well, a conditional seems appropiate and it is. Nonvetheless, this solution is really ugly. 
        </p>

        <h2>IMPROVEMENTS</h2>

        <section id = "explainshot">
        <table width=100% height=100%>
        <tr>
        <td style = "text-align: center; vertical align: middle;">
          <img src="/Blog/cs61b/images/improvesSList.png"  height  = "240"  width = "300">
        </td>
        </tr>
        </table>
        </section>


      </p>



    </section>
   

    <footer>
    <nav style = "text-align: center; vertical align: middle;">
    
    <a href="/index.html">Home</a> 
    <a href="acomplishments.html">List</a> 
    <a href="/schoolWork.html"> School Work</a> 
    <a href="/math.html">Math</a>
    <a href="/courses.html">Courses</a>
    </nav>
      <p align="center" > Made by <b>nonameable</b> </p>
    </footer>

  </body>
</html>
